// Solutions for Exercise 2: Functions and Error Handling

package functions

import "errors"

// 1. Divide
func Divide(a, b int) (int, int) {
	return a / b, a % b
}

// 2. DivideNamed
func DivideNamed(a, b int) (quotient, remainder int) {
	quotient = a / b
	remainder = a % b
	return
}

// 3. SafeDivide
func SafeDivide(a, b int) (int, error) {
	if b == 0 {
		return 0, errors.New("cannot divide by zero")
	}
	return a / b, nil
}

// 4. GetOperation
func GetOperation(op string) func(int, int) int {
	switch op {
	case "add":
		return func(a, b int) int { return a + b }
	case "subtract":
		return func(a, b int) int { return a - b }
	case "multiply":
		return func(a, b int) int { return a * b }
	default:
		return func(a, b int) int { return 0 }
	}
}

// 5. Sum
func Sum(numbers ...int) int {
	total := 0
	for _, n := range numbers {
		total += n
	}
	return total
}

// 6. MakeCounter
func MakeCounter() func() int {
	count := 0
	return func() int {
		count++
		return count
	}
}

// 7. MapInts
func MapInts(numbers []int, fn func(int) int) []int {
	result := make([]int, len(numbers))
	for i, n := range numbers {
		result[i] = fn(n)
	}
	return result
}
